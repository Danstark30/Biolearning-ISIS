# -*- coding: utf-8 -*-
"""ECG_continuacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OBHVGYkbyAei5e5vVRUeEKTDM5_w4EVP

#ONDA R
"""

#!pip install wfdb
import wfdb
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

señalecg,info = wfdb.rdsamp('100', pn_dir='mitdb', channels=[0])

#annotation = wfdb.rdann('/content/ECG_Apneam.mat', 'atr', sampto = 15000)
#annotation = wfdb.rdann('100', 'atr', sampto=3000, pn_dir='mitdb')
#annotation.fs = 100


ecg=señalecg[:1000]
fs=info['fs']
ts=1/fs
t=np.linspace(0,np.size(ecg),np.size(ecg))*ts
'''
new_fs = 1170   # New sampling frequency
ecg_resampled = signal.resample(ecg, int(len(ecg) * new_fs / fs))

# Calculate the new time vector for the resampled signal
ts_resampled = 1 / new_fs
t_resampled = np.linspace(0, np.size(ecg_resampled), np.size(ecg_resampled)) * ts_resampled
t=t_resampled
ecg=ecg_resampled
'''
plt.plot(t,ecg)
plt.grid()
plt.xlim(0, max(t))
plt.show()

"""#FILTRO"""

'''
ekg,inf = wfdb.rdsamp('100', pn_dir='mitdb', channels=[0], sampto=2000.)
fs=360
ts=1/fs #periodo
vector = np.arange(1,(len(señal)+1))
t=vector*ts
'''
señ=ecg
#filtro pasa bandas
b, a = signal.butter(N=4, btype = 'bandpass', Wn=[2.5,45], fs=fs) # Filtro pasabandas orden 3 butterworth, la fecuencia es por la naturaleza de la señal, limpia la señal

señfiltb=signal.filtfilt(b, a, señ, axis=0) 
plt.plot(t,ecg)
plt.grid()
plt.plot(t,señfiltb)
plt.show()

"""#SEÑAL FINAL R


"""

s, s1= 0, 200 # rango de ventana cada 200 ms
cont=1
señalf=señfiltb[s:s1]
picomax=float(max(señalf)) # identificar variable máxima dentro de la señalf (voltaje y tiempo)

xpicomax=np.argmax(señalf) # pico máximo en el tiempo (eje x)
maxin=[xpicomax]
maxiny=[picomax] # Espacio de memoria vacío para saber cuantos puntos hay
tiempomax=t[xpicomax] # vector de posición
plt.plot([tiempomax],picomax, 'or') # mostrar los picos máximos

# INICIO CICLO 

while s1<(len(señfiltb)): #cuando S1 (200) sea menor al tamaño de toda la señal(señfiltb) se hará el ciclo
  s+=200 #se incrementa sobre el valor anterior
  s1+=200 #se incrementa sobre el valor anterior
  señalf=señfiltb[s:s1] 
  picomax=float(max(señalf)) 
  xpicomax=s+np.argmax(señalf) # s es sobre el eje X, me dice dónde están ubicados los picos máximos
  tiempomax=t[xpicomax]

  picomin=float(min(señalf)) # identificar variable mínima dentro de la señalf (voltaje y tiempo)
  xpicomin=s+np.argmin(señalf) # s es sobre el eje X, me dice dónde están ubicados los picos mínimos
  tiempomin=t[xpicomin]

  if picomax > 0.7:  # por encima de 0,7 solo hay ondas R
    plt.plot([tiempomax], picomax, 'or') 
    cont+=1
    maxin.append(xpicomax) #añadir en la lista onda P
    maxiny.append(picomax)
  
  if picomin < -0.7:  # por debajo de -0,7 ondas R invertida
    plt.plot([tiempomin], picomin, 'or')
    cont+=1

fc= cont*(60/(max(t))) #frecuencia cardiaca en latidos por minuto
print(max(t))
print (f"la frecuencia cardiaca es:{fc}") # frecuencia cardiaca en forma de texto
plt.plot(t,señfiltb)
plt.xlim(0,max(t))
print(maxin)

print(len(maxin)) # para marcar TODO, maxin es un vector de ondas R

"""#ONDA P"""

picosam=[]
picos=[] # Espacio de memoria vacío picos P
i=0 # Rango de ventana es de pico R a pico R 
io=1 # Rango de ventana es de pico R a pico R 

#Inicio del ciclo onda P
while io<(len(maxin)): # cuando el último pico sea menor a maxin

  pico1=maxin[i] # Pico1 es i en posición
  pico2=maxin[io] # Pico2 es io en posición
  i+=1 #se incrementa sobre el valor anterior
  io+=1 #se incrementa sobre el valor anterior
  rr=pico2-pico1 # Tomo el intervalo pico a pico 
  pri=int(round((pico1+0.7*rr),0)) # Primer tiempo es 0,7 que es el comienzo de la ventana de la onda P, (round no redondear)
  sec=int(round((pico1+0.9*rr),0)) # Segundo tiempo es 0,9 que es el final de la ventana de la onda P, (round no redondear)
  
  rango=señfiltb[pri:sec] # ventana de la Onda P posición
  pico=max(rango) # Punto máximo de la ventana de la onda P

  pmp=pri+np.argmax(rango) # pri es sobre el eje X, me dice donde esta ubicado el punto maximo de la onda P
  tpmp=t[pmp] 
  plt.plot(tpmp,pico,'or') # Marca el punto
  picos.append(pico) # añadir en la lista en la onda P
  picosam.append(pmp)
  plt.plot(t,señfiltb)

  plt.title('señal ECG')
  plt.xlabel('t/segundos')
  plt.ylabel('mV')
  plt.grid()

"""# ONDA Q"""

oq=0
picoq=[]
xqpicos=[]
timeqpicos=[]

while oq < len(maxin):
  dfq=1
  c=0
  while dfq > 0:
    c+=1
    loc=maxin[oq]
    dfq=(señfiltb[loc-c+4]-señfiltb[loc-c-4])/8

  qvolt=señfiltb[maxin[oq]-c]
  picoq.append(señfiltb[maxin[oq]-c])
  xqpicos.append(maxin[oq]-c)
  qtime=t[maxin[oq]-c]
  plt.plot(qtime,qvolt,'vr')
  oq+=1

plt.plot(t,señfiltb)

"""# ONDA S"""

picosS=[] # Espacio de memoria vacío picos S
i=0 # Rango de ventana es de pico R a pico R 
io=1 # Rango de ventana es de pico R a pico R 

#Inicio del ciclo onda S
while io<(len(maxin)): # cuando el último pico sea menor a maxin

  pico1=maxin[i] # Pico1 es i en posición
  pico2=maxin[io] # Pico2 es io en posición
  i+=1 #se incrementa sobre el valor anterior
  io+=1 #se incrementa sobre el valor anterior
  rr=pico2-pico1 # Tomo el intervalo pico a pico 
  pri=int(round((pico1+0.01*rr),0)) # Primer tiempo es 0,01 que es el comienzo de la ventana de la onda S, (round no redondear)
  sec=int(round((pico1+0.1*rr),0)) # Segundo tiempo es 0,1 que es el final de la ventana de la onda S, (round no redondear)
  
  rango=señfiltb[pri:sec] # ventana de la Onda S posición
  pico_S=min(rango) # Punto mínimo de la ventana de la onda S

  if pico2 == max(maxin):
    pico_sf=min(señfiltb[pico2:-1])
    xpico_sf=pico2+np.argmin(señfiltb[pico2:-1])
    timepico_sf=t[xpico_sf]
    plt.plot(timepico_sf,pico_sf, 'or')

  pmpS=pri+np.argmin(rango) # pri es sobre el eje X, me dice donde esta ubicado el punto minimo de la onda S
  tpmpS=t[pmpS] 
  plt.plot(tpmpS,pico_S,'or') # Marca el punto
  picos.append(pico_S) # añadir en la lista en la onda S
  
  plt.plot(t,señfiltb)

  plt.title('señal ECG')
  plt.xlabel('t/segundos')
  plt.ylabel('mV')
  plt.grid()

"""#ONSET P"""

p=0
pnet=[]
ttpnet=[]
xpnet=[]
for pp in picosam:
  temp=pp
  while temp >= 0.15*señfiltb[pp]:
    p+=1
    rng=señfiltb[pp-p-2:pp-p+2]
    temp=np.mean(rng)
  pnet.append(señfiltb[pp-p])
  ttpnet.append(t[pp-p])
  xpnet.append(pp-p)

plt.plot(ttpnet,pnet, 'or')
plt.plot(t,señfiltb)

"""#OFFSET P"""

ofnet=[]
tofpnet=[]
xofpnet=[]

for pp in picosam:
  temp=pp
  while temp >= 0.15*señfiltb[pp]:
    p+=1
    rng=señfiltb[pp-p-2:pp-p+2]
    temp=np.mean(rng)
  ofnet.append(señfiltb[pp+p])
  tofpnet.append(t[pp+p])
  xofpnet.append(pp+p)
plt.plot(tofpnet,ofnet, 'or')
plt.plot(t,señfiltb)

"""#ONSET Q"""

onsetq=[]
tonsetq=[]
for qq in xqpicos:
  ddq=-1  
  qc=0
  while ddq < 0:
    qc+=1
    ddq=(señfiltb[qq-qc+2]-señfiltb[qq-qc-2])/4
  onsetq.append(señfiltb[qq-qc])
  tonsetq.append(t[qq-qc])
plt.plot(tonsetq,onsetq, 'or')
plt.plot(t,señfiltb)
plt.grid()

"""#CARACTERISTICAS ONDA P"""

altop=[]
anchop=[]
prseg=[]
areap=[]
HRV=[]
ttondap=[]
qrelectricanalternas=[]
u=range(len(picosam))
for px in u:

  altop.append(picos[px])
  anchop.append(tofpnet[px]-ttpnet[px])
  prseg.append(tonsetq[px]-tofpnet[px])
  for g in [xpnet[px],xofpnet[px]]:
    areap.append((señfiltb[g]-señfiltb[g+1])/fs)
    ttondap.append((t[g]))

  HRV.append(round(60/(maxiny[px+1]-maxiny[px])))
  qrelectricanalternas.append(maxiny[px]-picoq[px])

print(altop)
print(anchop)
print(prseg)
print(HRV)
print(qrelectricanalternas)

